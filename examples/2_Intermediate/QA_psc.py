#!/usr/bin/env python
r"""
This example script optimizes a set of relatively simple toroidal field coils
and passive superconducting coils (PSCs)
for an ARIES-CS reactor-scale version of the precise-QH stellarator from 
Landreman and Paul. 

The script should be run as:
    mpirun -n 1 python QH_psc_example.py
on a cluster machine but 
    python QH_psc_example.py
is sufficient on other machines. Note that this code does not use MPI, but is 
parallelized via OpenMP, so will run substantially
faster on multi-core machines (make sure that all the cores
are available to OpenMP, e.g. through setting OMP_NUM_THREADS).

"""
from pathlib import Path

import numpy as np
from scipy.optimize import minimize
from matplotlib import pyplot as plt
from simsopt.field import BiotSavart, Current, coils_via_symmetries, psc_coils_via_symmetries, apply_symmetries_to_curves
from simsopt.geo import SurfaceRZFourier, curves_to_vtk
from simsopt.geo.psc_grid import PSCgrid
from simsopt.objectives import SquaredFlux
from simsopt.util import in_github_actions
from simsopt.util.permanent_magnet_helper_functions import *
import time
import shutil

def coil_optimization_QA(s, bs, base_curves, curves):
    """
    Optimize the coils for the Landreman-Paul QA configuration.

    Args:
        s: plasma boundary.
        bs: Biot Savart class object, presumably representing the
          magnetic fields generated by the coils.
        base_curves: List of CurveXYZFourier class objects.
        curves: List of Curve class objects.
        out_dir: Path or string for the output directory for saved files.

    Returns:
        bs: Biot Savart class object, presumably representing the
          OPTIMIZED magnetic fields generated by the coils.
    """

    from simsopt.geo import CurveLength, CurveCurveDistance, \
        MeanSquaredCurvature, LpCurveCurvature, CurveSurfaceDistance
    from simsopt.objectives import QuadraticPenalty

    MAXITER = 1000

    nphi = len(s.quadpoints_phi)
    ntheta = len(s.quadpoints_theta)
    ncoils = len(base_curves)

    # Weight on the curve lengths in the objective function:
    LENGTH_WEIGHT = 0.5

    # Threshold and weight for the coil-to-coil distance penalty in the objective function:
    CC_THRESHOLD = 1.5
    CC_WEIGHT = 1  #1e-1

    # Threshold and weight for the coil-to-surface distance penalty in the objective function:
    CS_THRESHOLD = 3.7
    CS_WEIGHT = 1 #e-1  # 1e-1

    # Threshold and weight for the curvature penalty in the objective function:
    CURVATURE_THRESHOLD = 0.1
    CURVATURE_WEIGHT = 1e-5

    # Threshold and weight for the mean squared curvature penalty in the objective function:
    MSC_THRESHOLD = 0.1
    MSC_WEIGHT = 1e-5

    Jls = [CurveLength(c) for c in base_curves]
    Jccdist = CurveCurveDistance(curves, CC_THRESHOLD, num_basecurves=ncoils)
    Jcsdist = CurveSurfaceDistance(curves, s, CS_THRESHOLD)
    Jcs = [LpCurveCurvature(c, 2, CURVATURE_THRESHOLD) for c in base_curves]
    Jmscs = [MeanSquaredCurvature(c) for c in base_curves]

    Jf = SquaredFlux(s, bs)
    JF = Jf + LENGTH_WEIGHT * sum(Jls) \
        + CC_WEIGHT * Jccdist \
        + CS_WEIGHT * Jcsdist \
        + CURVATURE_WEIGHT * sum(Jcs) \
        + MSC_WEIGHT * sum(QuadraticPenalty(J, MSC_THRESHOLD) for J in Jmscs)

    def fun(dofs):
        """ Function for coil optimization grabbed from stage_two_optimization.py """
        JF.x = dofs
        J = JF.J()
        grad = JF.dJ()
        BdotN = np.mean(np.abs(np.sum(bs.B().reshape((nphi, ntheta, 3)) * s.unitnormal(), axis=2)))
        B_axis = calculate_on_axis_B(bs, s, print_out=False)
        bs.set_points(s.gamma().reshape(-1, 3))
        jf = Jf.J() / (B_axis ** 2 * s.area())
        outstr = f"J={J:.3e}, Jf={jf:.3e}, ⟨B·n⟩={BdotN:.3e}"
        cl_string = ", ".join([f"{J.J():.3f}" for J in Jls])
        kap_string = ", ".join(f"{np.max(c.kappa()):.3f}" for c in base_curves)
        msc_string = ", ".join(f"{J.J():.3f}" for J in Jmscs)
        outstr += f", Len=sum([{cl_string}])={sum(J.J() for J in Jls):.3f}, ϰ=[{kap_string}], ∫ϰ²/L=[{msc_string}]"
        outstr += f", C-C-Sep={Jccdist.shortest_distance():.3f}, C-S-Sep={Jcsdist.shortest_distance():.3f}"
        outstr += f", ║∇J║={np.linalg.norm(grad):.3e}"
        print(outstr)
        return J, grad

    print("""
    ################################################################################
    ### Perform a Taylor test ######################################################
    ################################################################################
    """)
    f = fun
    dofs = JF.x
    h = np.random.uniform(size=dofs.shape)

    J0, dJ0 = f(dofs)
    dJh = sum(dJ0 * h)
    for eps in [1e-3, 1e-4, 1e-5, 1e-6, 1e-7]:
        J1, _ = f(dofs + eps*h)
        J2, _ = f(dofs - eps*h)
        print("err", (J1-J2)/(2*eps) - dJh)
    print("""
    ################################################################################
    ### Run the optimisation #######################################################
    ################################################################################
    """)
    minimize(fun, dofs, jac=True, method='L-BFGS-B', options={'maxiter': MAXITER, 'maxcor': 100}, tol=1e-6)
    bs.set_points(s.gamma().reshape((-1, 3)))
    return bs

def coil_optimization_PSC(s, bs, bpsc):
    """
    Optimize the coils for the Landreman-Paul QA configuration.

    Args:
        s: plasma boundary.
        bs: Biot Savart class object, presumably representing the
          magnetic fields generated by the coils.
        base_curves: List of CurveXYZFourier class objects.
        curves: List of Curve class objects.
        out_dir: Path or string for the output directory for saved files.

    Returns:
        bs: Biot Savart class object, presumably representing the
          OPTIMIZED magnetic fields generated by the coils.
    """    
    Btot = bs + bpsc

    nphi = len(s.quadpoints_phi)
    ntheta = len(s.quadpoints_theta)

    # print('num_coils = ', len(bpsc._coils))
    for j in range(len(bpsc._coils)):
        names = bpsc._coils[j]._curve.local_dof_names
        # print(j, names)
        if len(names) > 0: 
            bpsc._coils[j]._current.fix_all()
            for i in range(2 * bpsc._coils[0]._curve.order + 1):
                bpsc._coils[j]._curve.fix(names[i])
            bpsc._coils[j]._curve.fix(names[2 * bpsc._coils[j]._curve.order + 5])
            bpsc._coils[j]._curve.fix(names[2 * bpsc._coils[j]._curve.order + 6])
            bpsc._coils[j]._curve.fix(names[2 * bpsc._coils[j]._curve.order + 7])

    print(Btot.dof_names)
    print([bpsc._coils[j]._current.get_value() for j in range(len(bpsc._coils))])

    Jf = SquaredFlux(s, Btot)
    B_axis = calculate_on_axis_B(bs, s, print_out=False)
    bs.set_points(s.gamma().reshape(-1, 3))
    # print(bpsc._coils[0]._psc_array.least_squares(bpsc._coils[0]._psc_array.kappas))
    # print(bpsc._coils[0]._curve.dof_names)
    print('Jf initial = ', Jf.J() / (B_axis ** 2 * s.area()))
    # Don't need other terms until let the coils move around
    JF = Jf 

    def fun(dofs):
        """ Function for coil optimization grabbed from stage_two_optimization.py """
        JF.x = dofs
        # print('dofs = ', dofs)
        # print(JF.dof_names)
        # Get the dofs for the PSCs, convert to alphas and deltas, and update the coils
        # dofs = dofs.reshape(-1, 4)
        # dofs = (dofs.T / np.sqrt(np.sum(dofs ** 2, axis=-1))).T  # normalize the quaternion
        # alphas = np.arctan2(2 * (dofs[:, 0] * dofs[:, 1] + dofs[:, 2] * dofs[:, 3]), 
        #                     1 - 2.0 * (dofs[:, 1] ** 2 + dofs[:, 2] ** 2))
        # deltas = -np.pi / 2.0 + 2.0 * np.arctan2(
        #     np.sqrt(1.0 + 2 * (dofs[:, 0] * dofs[:, 2] - dofs[:, 1] * dofs[:, 3])), 
        #     np.sqrt(1.0 - 2 * (dofs[:, 0] * dofs[:, 2] - dofs[:, 1] * dofs[:, 3])))
        # print('a, d = ', np.max(np.abs(alphas)), np.max(np.abs(deltas)))
        # pscs = bpsc._coils[0]._psc_array
        # pscs.setup_orientations(alphas, deltas)
        # pscs.update_curves()
        # pscs.update_psi()
        # pscs.setup_currents_and_fields()
        # pscs.psi_deriv_full()
        # print('a1, a2 = ', pscs.alphas, bpsc._coils[-1]._psc_array.I, bpsc._coils[-1]._psc_array.dpsi)
        # exit()
        
        J = JF.J()
        grad = JF.dJ()
        # print(bpsc._coils[0]._curve.gamma()[-1, :], bpsc._coils[0]._current.get_value())
        # print('grad = ', grad, grad.shape)
        BdotN = np.mean(np.abs(np.sum(Btot.B().reshape((nphi, ntheta, 3)) * s.unitnormal(), axis=2)))
        B_axis = calculate_on_axis_B(bs, s, print_out=False)
        bs.set_points(s.gamma().reshape(-1, 3))
        jf = Jf.J() / (B_axis ** 2 * s.area())
        grad = grad / (B_axis ** 2 * s.area())
        outstr = f"J={J:.3e}, Jf={jf:.3e}, ⟨B·n⟩={BdotN:.3e}"
        Bnnormed = BdotN / (B_axis * s.area())
        outstr += f", ║∇J║={np.linalg.norm(grad):.3e}"
        print(outstr)
        return J, grad

    # print("""
    # ################################################################################
    # ### Perform a Taylor test ######################################################
    # ################################################################################
    # """)
    # f = fun
    dofs = JF.x
    # h = np.random.uniform(size=dofs.shape)

    # J0, dJ0 = f(dofs)
    # dJh = sum(dJ0 * h)
    # for eps in [1e-3, 1e-4, 1e-5, 1e-6, 1e-7]:
    #     J1, _ = f(dofs + eps*h)
    #     J2, _ = f(dofs - eps*h)
    #     print("err", (J1-J2)/(2*eps) - dJh)

    print("""
    ################################################################################
    ### Run the optimisation #######################################################
    ################################################################################
    """)
    MAXITER = 1000
    minimize(fun, dofs, jac=True, 
             method='L-BFGS-B', 
             options={'maxiter': MAXITER, 'maxcor': 500}, 
             tol=1e-20)
    return bs

np.random.seed(1)  # set a seed so that the same PSCs are initialized each time
nphi = 64  # nphi = ntheta >= 64 needed for accurate full-resolution runs
ntheta = nphi
# Make higher resolution surface for plotting Bnormal
qphi = nphi * 2
quadpoints_phi = np.linspace(0, 1, qphi, endpoint=True)
quadpoints_theta = np.linspace(0, 1, ntheta * 2, endpoint=True)

poff = 1.5  # PSC grid will be offset 'poff' meters from the plasma surface
coff = 0.5  # PSC grid will be initialized between 1 m and 2 m from plasma

# Read in the plasma equilibrium file
input_name = 'input.LandremanPaul2021_QA_reactorScale_lowres'
TEST_DIR = (Path(__file__).parent / ".." / ".." / "tests" / "test_files").resolve()
surface_filename = TEST_DIR / input_name
range_param = 'half period'
s = SurfaceRZFourier.from_vmec_input(
    surface_filename, range=range_param, nphi=nphi, ntheta=ntheta
)
# Print major and minor radius
print('s.R = ', s.get_rc(0, 0))
print('s.r = ', s.get_rc(1, 0))

# Make inner and outer toroidal surfaces very high resolution,
# which helps to initialize coils precisely between the surfaces. 
s_inner = SurfaceRZFourier.from_vmec_input(
    surface_filename, range=range_param, nphi=nphi * 4, ntheta=ntheta * 4
)
s_outer = SurfaceRZFourier.from_vmec_input(
    surface_filename, range=range_param, nphi=nphi * 4, ntheta=ntheta * 4
)

# Make the inner and outer surfaces by extending the plasma surface
s_inner.extend_via_normal(poff)
s_outer.extend_via_normal(poff + coff)

# Remake the output directory and erase previous files (to avoid confusion)
out_str = "QA_temp/"
try:
    shutil.rmtree(out_str)
except OSError as e:
    print("Error: %s - %s." % (e.filename, e.strerror))
out_dir = Path("QA_temp")
out_dir.mkdir(parents=True, exist_ok=True)

# Save the inner and outer surfaces for debugging purposes
s_inner.to_vtk(out_str + 'inner_surf')
s_outer.to_vtk(out_str + 'outer_surf')

def initialize_coils_qa():
    from simsopt.geo import create_equally_spaced_curves
    from simsopt.field import Current, coils_via_symmetries
    from simsopt.mhd.vmec import Vmec
    
    # generate planar TF coils
    ncoils = 3
    R0 = s.get_rc(0, 0)
    R1 = s.get_rc(1, 0) * 5
    order = 1

    # qa needs to be scaled to 5.7 T on-axis magnetic field strength
    vmec_file = 'wout_LandremanPaul2021_QA_reactorScale_lowres_reference.nc'
    total_current = Vmec(TEST_DIR / vmec_file).external_current() / (2 * s.nfp) * 0.85  #  / 7.131 * 6 / 1.01
    base_curves = create_equally_spaced_curves(ncoils, s.nfp, stellsym=True, R0=R0, R1=R1, order=order, numquadpoints=64)
    base_currents = [(Current(total_current / ncoils * 1e-5) * 1e5) for _ in range(ncoils - 1)]
    # base_currents[0].fix_all()
    total_current = Current(total_current)
    total_current.fix_all()
    base_currents += [total_current - sum(base_currents)]
    coils = coils_via_symmetries(base_curves, base_currents, s.nfp, True)
    # fix all the coil shapes so only the currents are optimized
    # for i in range(ncoils):
        # base_curves[i].fix_all()
        # base_currents[i].fix_all()
        
    # Initialize the coil curves and save the data to vtk
    curves = [c.curve for c in coils]
    curves_to_vtk(curves, out_dir / "curves_init")
    return base_curves, curves, coils

# initialize the coils
base_curves, curves, coils = initialize_coils_qa()
currents = np.array([coil.current.get_value() for coil in coils])
bs = BiotSavart(coils)

# Calculate average, approximate on-axis B field strength
calculate_on_axis_B(bs, s)

# Make high resolution, full torus version of the plasma boundary for plotting
s_plot = SurfaceRZFourier.from_vmec_input(
    surface_filename, 
    quadpoints_phi=quadpoints_phi, 
    quadpoints_theta=quadpoints_theta
)
# s_plot.save(filename=out_dir / 'plasma_boundary.json')

# Plot initial Bnormal on plasma surface from un-optimized BiotSavart coils
make_Bnormal_plots(bs, s_plot, out_dir, "biot_savart_initial")

# optimize the currents in the TF coils and plot results
bs = coil_optimization_QA(s, bs, base_curves, curves)
# bs.save('B_TF.json')
currents = np.array([coil.current.get_value() for coil in coils])
curves_to_vtk(curves, out_dir / "TF_0", close=True)
bs.set_points(s.gamma().reshape((-1, 3)))
Bnormal = np.sum(bs.B().reshape((nphi, ntheta, 3)) * s.unitnormal(), axis=2)
B_axis = calculate_on_axis_B(bs, s)
make_Bnormal_plots(bs, s_plot, out_dir, "BTF_0", B_axis)

# Finally, initialize the psc class
kwargs_geo = {"Nx": 12, "out_dir": out_str,
                "initialization": "plasma", 
              "poff": poff,}

psc_array = PSCgrid.geo_setup_between_toroidal_surfaces(
    s, coils, s_inner, s_outer,  **kwargs_geo
)
psc_array.I = np.ones(len(psc_array.I)) * 1e7

print('Number of PSC locations = ', len(psc_array.grid_xyz))

# Plot initial errors from only the PSCs, and then together with the TF coils
make_Bnormal_plots(psc_array.B_PSC, s_plot, out_dir, "biot_savart_PSC_initial", B_axis)
make_Bnormal_plots(bs + psc_array.B_PSC, s_plot, out_dir, "B_0", B_axis)

# Check SquaredFlux values using different ways to calculate it
x0 = np.ravel(np.array([psc_array.alphas, psc_array.deltas]))

fB = SquaredFlux(s, bs, np.zeros((nphi, ntheta))).J()
fB_TF = fB / (B_axis ** 2 * s.area())
print('fB only TF coils = ', fB_TF)
bs.set_points(s.gamma().reshape(-1, 3))
Bnormal = np.sum(bs.B().reshape((nphi, ntheta, 3)) * s.unitnormal(), axis=2)
print('fB only TF direct = ', np.sum(Bnormal.reshape(-1) ** 2 * psc_array.grid_normalization ** 2
                                    ) / (2 * B_axis ** 2 * s.area()))
currents_psc = []
# print(psc_array.I)
for i in range(psc_array.num_psc):
    currents_psc.append(Current(psc_array.I[i] * 1e-6) * 1e6)
all_coils = coils_via_symmetries(
    psc_array.curves, currents_psc, nfp=psc_array.nfp, stellsym=psc_array.stellsym, # psc_array=psc_array
)
bpsc = BiotSavart(all_coils)
bpsc.set_points(s.gamma().reshape((-1, 3)))

make_Bnormal_plots(bpsc, s_plot, out_dir, "biot_savart_PSC_initial", B_axis)
fB = SquaredFlux(s, bpsc, np.zeros((nphi, ntheta))).J()
print(fB/ (B_axis ** 2 * s.area()))
fB = SquaredFlux(s, bpsc + bs, np.zeros((nphi, ntheta))).J()
print('fB with both, before opt = ', fB / (B_axis ** 2 * s.area()))

fB = SquaredFlux(s, bpsc, -Bnormal).J()
print('fB with both (minus sign), before opt = ', fB / (B_axis ** 2 * s.area()))

# Actually do the minimization now
print('beginning optimization: ')
options = {"disp": True, "maxiter": 50}  # 100
verbose = True
eps = 1e-6
opt_bounds1 = tuple([(-np.pi / 2.0 + eps, np.pi / 2.0 - eps) for i in range(psc_array.num_psc)])
opt_bounds2 = tuple([(-np.pi + eps, np.pi - eps) for i in range(psc_array.num_psc)])
opt_bounds = np.vstack((opt_bounds1, opt_bounds2))
opt_bounds = tuple(map(tuple, opt_bounds))
x_opt = minimize(psc_array.least_squares, 
                  x0, 
                  args=(verbose,),
                  method='L-BFGS-B',
                  bounds=opt_bounds,
                    jac=psc_array.least_squares_jacobian, 
                  options=options,
                  tol=1e-20,  # Required to make progress when fB is small
                  # callback=callback
                  )
psc_array.setup_curves()
psc_array.plot_curves('PSCs_0_')
B_tot = bs + bpsc
make_Bnormal_plots(B_tot, s_plot, out_dir, 'B_0', B_axis)

psc_array.setup_curves()
psc_array.plot_curves('final_')
make_Bnormal_plots(bpsc, s_plot, out_dir, "biot_savart_PSC_1", B_axis)
bs.set_points(s.gamma().reshape((-1, 3)))
bpsc.set_points(s.gamma().reshape((-1, 3)))

Bnormal = np.sum(bs.B().reshape((nphi, ntheta, 3)) * s.unitnormal(), axis=2)
B_tot = bs + bpsc
make_Bnormal_plots(B_tot, s_plot, out_dir, 'Bjoint_1', B_axis)

currents_psc = []
# print(psc_array.I)
for i in range(psc_array.num_psc):
    currents_psc.append(Current(psc_array.I[i] * 1e-6) * 1e6)
all_coils = coils_via_symmetries(
    psc_array.curves, currents_psc, nfp=psc_array.nfp, stellsym=psc_array.stellsym, # psc_array=psc_array
)
bpsc = BiotSavart(all_coils)
bs.set_points(s.gamma().reshape((-1, 3)))
bpsc.set_points(s.gamma().reshape((-1, 3)))
Bn_psc = np.sum(bpsc.B().reshape(-1, 3) * psc_array.plasma_unitnormals, axis=-1) * psc_array.grid_normalization
Bn_TF = np.sum(bs.B().reshape(-1, 3) * psc_array.plasma_unitnormals, axis=-1) * psc_array.grid_normalization
B2 = np.sum((Bn_psc + Bn_TF) ** 2) * 0.5 / (B_axis ** 2 * s.area())
print('B2 = ', B2)
# base_currents[0].fix_all()

#### Now fix the currents in the TF before doing the second opt.
for i in range(len(bs._coils)):
    bs._coils[i]._curve.fix_all()
    bs._coils[i]._current.fix_all()
bs = coil_optimization_PSC(s, bs, bpsc)
curves = [bpsc._coils[i]._curve for i in range(len(bpsc._coils))]
currents = [bpsc._coils[i]._current.get_value() for i in range(len(bpsc._coils))]
# print('I = ', currents, psc_array.I)
psc_array.curves = curves
psc_array.all_curves = apply_symmetries_to_curves(curves, s.nfp, s.stellsym)
psc_array.plot_curves('Direct_opt_')
make_Bnormal_plots(bpsc, s_plot, out_dir, "biot_savart_PSC_2", B_axis)

currents = np.array([coil.current.get_value() for coil in coils])
curves_to_vtk(curves, out_dir / "TF_0", close=True)
bs.set_points(s.gamma().reshape((-1, 3)))
Bnormal = np.sum(bs.B().reshape((nphi, ntheta, 3)) * s.unitnormal(), axis=2)
B_tot = bs + bpsc
make_Bnormal_plots(B_tot, s_plot, out_dir, 'Bjoint_2', B_axis)

###
fB = SquaredFlux(s, bpsc + bs, np.zeros((nphi, ntheta))).J()
print('fB with both, after opt = ', fB / (B_axis ** 2 * s.area()))
make_Bnormal_plots(bpsc, s_plot, out_dir, "PSC_final", B_axis)
make_Bnormal_plots(bs + bpsc, s_plot, out_dir, "PSC_and_TF_final", B_axis)

